# Migration Strategy Document

## Document Information

| Item | Details |
|------|---------|
| **Project Name** | {{project.name}} |
| **Migration Type** | {{project.migration_type}} |
| **Document Type** | Migration Strategy |
| **Generated Date** | {{generated_date}} |
| **Version** | {{version}} |
| **Author** | {{author}} |

---

## Executive Summary

This document outlines the comprehensive migration strategy for migrating the **{{project.name}}** application from PostgreSQL to Oracle database. The strategy emphasizes **minimal Java application changes**, focusing migration efforts on the database layer while preserving business logic.

### Migration Principles

1. **Keep Java Application Logic Unchanged** - NO business logic refactoring
2. **Database Layer Migration Only** - Focus on DDL, SQL queries, stored procedures
3. **Acceptable Java Changes:** Entity mappings, Repository queries, DB configurations
4. **Risk Mitigation** - Phased approach with comprehensive testing at each stage

### Migration Timeline Overview

- **Phase 1:** Database Schema Migration (DDL conversion)
- **Phase 2:** Application Layer Updates (minimal Java changes)
- **Phase 3:** Stored Procedures & Functions Conversion
- **Phase 4:** Data Migration
- **Phase 5:** Testing & Validation
- **Phase 6:** Deployment & Cutover

---

## 1. Migration Approach

### 1.1 Overall Strategy

**Migration Type:** Database Platform Migration with Minimal Application Changes

**Approach:** Big Bang vs. Phased
- **Recommended:** Phased migration by application module
- **Rationale:** Reduces risk, allows for iterative testing, enables rollback per module

### 1.2 Key Constraints

1. **Business Continuity:** Minimize downtime during cutover
2. **Data Integrity:** Zero data loss tolerance
3. **Application Stability:** No changes to business logic
4. **Performance:** Maintain or improve query performance
5. **Timeline:** [Define project timeline]

---

## 2. Database Migration Strategy

### 2.1 Schema Migration Approach

#### Phase 1: DDL Conversion

**Complexity Score:** {{metadata.migrationComplexity.schemaDataTypeComplexity}}/100

**Steps:**
1. **Extract PostgreSQL DDL** - Use pg_dump to extract current schema
2. **Convert Data Types** - Map PostgreSQL types to Oracle equivalents
3. **Recreate Constraints** - Convert CHECK, FOREIGN KEY, UNIQUE constraints
4. **Handle Sequences** - Convert SERIAL/BIGSERIAL to Oracle SEQUENCES with triggers
5. **Recreate Indexes** - Convert GIN/GIST/BRIN to Oracle index types

**Tools:**
- Oracle SQL Developer with PostgreSQL migration plugin
- Ora2Pg (open-source migration tool)
- Custom conversion scripts

**Data Type Conversion Strategy:**

{{#each metadata.source_analysis.postgresqlFeatures.dataTypes}}
**{{this.type}}** → **{{this.suggestedOracleType}}**
- Complexity: {{this.oracleMappingComplexity}}
- Affected Tables: {{#each this.tables}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}
- Required Actions: {{#if (eq this.oracleMappingComplexity "Complex")}}Custom conversion logic required{{else}}Direct mapping{{/if}}
{{/each}}

#### Phase 2: Index Strategy

**Current Index Types:**
{{#each metadata.source_analysis.postgresqlFeatures.advancedIndexes}}
- **{{this.type}}** ({{this.count}} indexes) - Oracle Support: {{#if this.oracleSupport}}Native{{else}}Alternative approach needed{{/if}}
{{/each}}

**Conversion Plan:**
- **GIN Indexes** → Oracle Text indexes or function-based indexes
- **GIST Indexes** → Oracle Spatial indexes (for geometry) or B-tree
- **BRIN Indexes** → Partitioned table with local indexes
- **Partial Indexes (WHERE clause)** → Function-based indexes or partitioning

#### Phase 3: Stored Procedures & Functions

**Complexity Score:** {{metadata.migrationComplexity.procedureFunctionTriggerComplexity}}/100

**Total Functions/Procedures:** {{metadata.source_analysis.database.functions}} functions + {{metadata.source_analysis.database.stored_procedures}} procedures

**Conversion Strategy:**
1. **Analyze PL/pgSQL Code** - Identify PostgreSQL-specific syntax
2. **Convert to PL/SQL** - Rewrite using Oracle syntax
3. **Handle Dynamic SQL** - Extra caution for SQL injection prevention
4. **Convert RETURNS TABLE** - Use SYS_REFCURSOR or pipelined functions
5. **Test Each Function** - Unit tests for all procedures

**Key Challenges:**
{{#each metadata.migrationComplexity.details.procedureFunctionTrigger}}
- {{this}}
{{/each}}

### 2.2 Data Migration Strategy

**Complexity Score:** {{metadata.migrationComplexity.dataVolumeMigrationComplexity}}/100

**Total Tables:** {{metadata.source_analysis.database.tables}}
**Partitioned Tables:** {{metadata.source_analysis.database.partitionedTables}}

#### Data Migration Tools

**Option 1: Oracle Data Pump (Recommended for Large Datasets)**
- Extract data from PostgreSQL using pg_dump (CSV format)
- Transform data to Oracle format
- Load using Oracle Data Pump (impdp)
- Fastest for large volumes (>100GB)

**Option 2: AWS Database Migration Service (DMS)**
- Supports continuous replication
- Minimal downtime migration
- Good for phased migration approach
- Handles heterogeneous migrations

**Option 3: Custom ETL Scripts**
- Full control over transformation logic
- Good for complex data transformations
- Use for special cases (JSONB, ARRAY conversions)

#### Data Migration Phases

**Phase 1: Initial Data Load**
1. Take application offline or set to read-only
2. Export PostgreSQL data
3. Transform data (handle type conversions)
4. Load into Oracle
5. Validate row counts and checksums

**Phase 2: Delta Synchronization** (if using phased approach)
1. Capture changes in PostgreSQL during initial load
2. Apply delta changes to Oracle
3. Repeat until cutover window

**Phase 3: Final Cutover**
1. Stop PostgreSQL writes
2. Apply final delta
3. Switch application to Oracle
4. Validate

---

## 3. Application Layer Migration Strategy

### 3.1 Minimal Java Changes Principle

**CRITICAL RULE:** Keep Java application logic unchanged.

**ORM Framework:** {{metadata.source_analysis.ormFramework}}

### 3.2 Required Java Changes (Database Layer Only)

#### 3.2.1 Entity Mappings

**Files Requiring Update:** {{metadata.javaChanges.acceptable.entityMappings.length}}

**Changes:**
- Update `@Column` annotations if data type mapping requires it
- Add `@Type` annotations for custom type handlers (JSONB → JSON)
- Update `@Table` annotations if table names change
- **Keep entity business methods unchanged**

**Example:**
```java
// Before (PostgreSQL)
@Column(columnDefinition = "jsonb")
private String metadata;

// After (Oracle)
@Column(columnDefinition = "CLOB")
@Type(type = "json")
private String metadata;
```

#### 3.2.2 Repository Queries

**Files Requiring Update:** {{metadata.javaChanges.acceptable.repositoryQueries.length}}

**Changes:**
- Rewrite SQL in `@Query` annotations for Oracle syntax
- Update MyBatis XML mapper files
- Replace PostgreSQL functions with Oracle equivalents
- **Keep method signatures, parameters, and return types unchanged**

**Common SQL Rewrites:**
- `LIMIT n` → `FETCH FIRST n ROWS ONLY`
- `array_agg()` → `LISTAGG()`
- `RETURNING` → `RETURNING` (different syntax)
- `ON CONFLICT` → `MERGE` statement
- `ILIKE` → `UPPER() LIKE UPPER()`

#### 3.2.3 Database Configurations

**Files Requiring Update:** {{metadata.javaChanges.acceptable.configurations.length}}

**Changes:**
1. **JDBC Driver:**
   ```properties
   # Before
   spring.datasource.driver-class-name=org.postgresql.Driver
   spring.datasource.url=jdbc:postgresql://localhost:5432/mydb

   # After
   spring.datasource.driver-class-name=oracle.jdbc.OracleDriver
   spring.datasource.url=jdbc:oracle:thin:@localhost:1521:ORCL
   ```

2. **Hibernate Dialect:**
   ```properties
   # Before
   spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

   # After
   spring.jpa.database-platform=org.hibernate.dialect.Oracle12cDialect
   ```

3. **Connection Pool Settings:**
   - Update for Oracle optimal settings
   - Adjust max pool size based on Oracle licensing

#### 3.2.4 Files Requiring Review

{{#if metadata.javaChanges.requiresReview.length}}
**⚠️ Warning: The following files have database dependencies in business logic:**

{{#each metadata.javaChanges.requiresReview}}
- {{this}}
{{/each}}

**Action Required:** Review these files carefully. Service/Controller layers should NOT have direct database dependencies.
{{else}}
✓ No files requiring special review - good separation of concerns.
{{/if}}

### 3.3 ORM Framework-Specific Strategy

**Detected Framework:** {{metadata.source_analysis.ormFramework}}

{{#if (eq metadata.source_analysis.ormFramework "Spring Data JPA")}}
**Spring Data JPA Strategy:**
- Update `@Query` annotations with Oracle SQL
- Test all custom queries
- Verify JPA entity mappings work with Oracle
- No changes to repository method signatures
{{else if (eq metadata.source_analysis.ormFramework "MyBatis")}}
**MyBatis Strategy:**
- Update all XML mapper files
- Replace PostgreSQL-specific SQL syntax
- Test all select/insert/update/delete statements
- No changes to mapper interface methods
{{else if (eq metadata.source_analysis.ormFramework "Hibernate")}}
**Hibernate Strategy:**
- Update Hibernate dialect configuration
- Test all HQL and Criteria queries
- Verify entity mappings
- No changes to DAO/Repository classes
{{/if}}

---

## 4. PostgreSQL Extensions Migration

{{#if metadata.source_analysis.postgresqlFeatures.extensions.length}}
**Extensions Detected:** {{metadata.source_analysis.postgresqlFeatures.extensions.length}}

{{#each metadata.source_analysis.postgresqlFeatures.extensions}}
### Extension: {{this}}

**Oracle Equivalent:**
{{#if (eq this "uuid-ossp")}}
- Use Oracle `SYS_GUID()` function
- Or install Oracle UUID package
{{else if (eq this "pg_trgm")}}
- Use Oracle Text for full-text search
- Configure CONTEXT indexes
{{else if (eq this "PostGIS")}}
- Use Oracle Spatial and Graph
- Migrate geometry data to SDO_GEOMETRY
{{else if (eq this "hstore")}}
- Redesign as key-value table
- Or use Oracle JSON_TABLE
{{else}}
- Custom research required for this extension
{{/if}}

{{/each}}
{{else}}
No PostgreSQL extensions detected - simplifies migration.
{{/if}}

---

## 5. Testing Strategy Overview

### 5.1 Testing Phases

**Phase 1: Unit Testing**
- Test all Entity mappings
- Test all Repository queries
- Test all stored procedures/functions

**Phase 2: Integration Testing**
- Test all service layer operations
- Test transaction management
- Test connection pooling

**Phase 3: Performance Testing**
- Compare query execution times
- Validate Oracle execution plans
- Load testing with production-like data

**Phase 4: Data Validation**
- Row count verification
- Data integrity checks
- Referential integrity validation

See Test Strategy document for detailed test plan.

---

## 6. Rollback Strategy

### 6.1 Rollback Triggers

**Rollback will be initiated if:**
1. Critical data integrity issues detected
2. Performance degradation >20% from baseline
3. Application errors exceed threshold
4. Business-critical functionality failure

### 6.2 Rollback Process

**Steps:**
1. Stop Oracle database connections
2. Switch application back to PostgreSQL
3. Sync any data changes from Oracle back to PostgreSQL (if needed)
4. Restart application
5. Validate functionality

**Rollback Time Estimate:** [Define based on deployment approach]

---

## 7. Risk Mitigation Strategies

{{#each metadata.risks}}
### Risk: {{this.category}}

**Severity:** {{this.severity}}
**Description:** {{this.description}}

**Mitigation:**
{{this.mitigation}}

---
{{/each}}

---

## 8. Resource Requirements

### 8.1 Team Requirements

| Role | Responsibilities | Estimated Effort |
|------|-----------------|-----------------|
| Database Architect | DDL conversion, stored procedure migration | [Estimate] |
| Backend Developer | Java code updates (minimal), testing | [Estimate] |
| DBA (PostgreSQL) | Data extraction, validation | [Estimate] |
| DBA (Oracle) | Schema creation, optimization | [Estimate] |
| QA Engineer | Testing, validation | [Estimate] |
| DevOps Engineer | Deployment, monitoring | [Estimate] |

### 8.2 Infrastructure Requirements

| Component | Specification |
|-----------|--------------|
| Oracle Database | Version 12c+ (for JSON support) |
| Server Hardware | [Define based on PostgreSQL usage] |
| Storage | [Define based on data volume] |
| Network | High-speed connection for data migration |
| Backup Infrastructure | Oracle RMAN or equivalent |

### 8.3 Tool Requirements

- Oracle SQL Developer
- Ora2Pg migration tool
- AWS DMS (if using cloud migration)
- Oracle Data Pump utilities
- Git for version control
- JIRA or equivalent for tracking

---

## 9. Success Criteria

### 9.1 Technical Success Criteria

- ✓ All database tables migrated with 100% data integrity
- ✓ All stored procedures/functions converted and tested
- ✓ All application queries return correct results
- ✓ Performance meets or exceeds PostgreSQL baseline
- ✓ Zero business logic changes
- ✓ All integration tests passing
- ✓ Zero data loss during migration

### 9.2 Business Success Criteria

- ✓ Application downtime within acceptable window
- ✓ No impact to end-user functionality
- ✓ Business processes continue without interruption
- ✓ Compliance and audit requirements met

---

## 10. Next Steps

1. **Review and Approve Strategy** - Stakeholder sign-off
2. **Detailed Migration Design** - Create detailed technical design document
3. **Set Up Environments** - Development, QA, Staging, Production
4. **Create Test Plan** - Detailed test cases and scenarios
5. **Begin Development** - DDL conversion and Java updates
6. **Pilot Migration** - Test with non-critical module first
7. **Full Migration** - Execute based on lessons learned

---

**Document End**
